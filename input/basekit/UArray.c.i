# 1 "UArray.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 31 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "<command-line>" 2
# 1 "UArray.c"





# 1 "Base.h" 1



# 1 "/home/user/Development/Python/C/utils/fake_libc_include/stdio.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stdio.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_typedefs.h" 1



typedef int size_t;
typedef int __builtin_va_list;
typedef int __gnuc_va_list;
typedef int va_list;
typedef int __int8_t;
typedef int __uint8_t;
typedef int __int16_t;
typedef int __uint16_t;
typedef int __int_least16_t;
typedef int __uint_least16_t;
typedef int __int32_t;
typedef int __uint32_t;
typedef int __int64_t;
typedef int __uint64_t;
typedef int __int_least32_t;
typedef int __uint_least32_t;
typedef int __s8;
typedef int __u8;
typedef int __s16;
typedef int __u16;
typedef int __s32;
typedef int __u32;
typedef int __s64;
typedef int __u64;
typedef int _LOCK_T;
typedef int _LOCK_RECURSIVE_T;
typedef int _off_t;
typedef int __dev_t;
typedef int __uid_t;
typedef int __gid_t;
typedef int _off64_t;
typedef int _fpos_t;
typedef int _ssize_t;
typedef int wint_t;
typedef int _mbstate_t;
typedef int _flock_t;
typedef int _iconv_t;
typedef int __ULong;
typedef int __FILE;
typedef int ptrdiff_t;
typedef int wchar_t;
typedef int __off_t;
typedef int __pid_t;
typedef int __loff_t;
typedef int u_char;
typedef int u_short;
typedef int u_int;
typedef int u_long;
typedef int ushort;
typedef int uint;
typedef int clock_t;
typedef int time_t;
typedef int daddr_t;
typedef int caddr_t;
typedef int ino_t;
typedef int off_t;
typedef int dev_t;
typedef int uid_t;
typedef int gid_t;
typedef int pid_t;
typedef int key_t;
typedef int ssize_t;
typedef int mode_t;
typedef int nlink_t;
typedef int fd_mask;
typedef int _types_fd_set;
typedef int clockid_t;
typedef int timer_t;
typedef int useconds_t;
typedef int suseconds_t;
typedef int FILE;
typedef int fpos_t;
typedef int cookie_read_function_t;
typedef int cookie_write_function_t;
typedef int cookie_seek_function_t;
typedef int cookie_close_function_t;
typedef int cookie_io_functions_t;
typedef int div_t;
typedef int ldiv_t;
typedef int lldiv_t;
typedef int sigset_t;
typedef int __sigset_t;
typedef int _sig_func_ptr;
typedef int sig_atomic_t;
typedef int __tzrule_type;
typedef int __tzinfo_type;
typedef int mbstate_t;
typedef int sem_t;
typedef int pthread_t;
typedef int pthread_attr_t;
typedef int pthread_mutex_t;
typedef int pthread_mutexattr_t;
typedef int pthread_cond_t;
typedef int pthread_condattr_t;
typedef int pthread_key_t;
typedef int pthread_once_t;
typedef int pthread_rwlock_t;
typedef int pthread_rwlockattr_t;
typedef int pthread_spinlock_t;
typedef int pthread_barrier_t;
typedef int pthread_barrierattr_t;
typedef int jmp_buf;
typedef int rlim_t;
typedef int sa_family_t;
typedef int sigjmp_buf;
typedef int stack_t;
typedef int siginfo_t;
typedef int z_stream;


typedef int int8_t;
typedef int uint8_t;
typedef int int16_t;
typedef int uint16_t;
typedef int int32_t;
typedef int uint32_t;
typedef int int64_t;
typedef int uint64_t;


typedef int int_least8_t;
typedef int uint_least8_t;
typedef int int_least16_t;
typedef int uint_least16_t;
typedef int int_least32_t;
typedef int uint_least32_t;
typedef int int_least64_t;
typedef int uint_least64_t;


typedef int int_fast8_t;
typedef int uint_fast8_t;
typedef int int_fast16_t;
typedef int uint_fast16_t;
typedef int int_fast32_t;
typedef int uint_fast32_t;
typedef int int_fast64_t;
typedef int uint_fast64_t;


typedef int intptr_t;
typedef int uintptr_t;


typedef int intmax_t;
typedef int uintmax_t;


typedef _Bool bool;


typedef void* MirEGLNativeWindowType;
typedef void* MirEGLNativeDisplayType;
typedef struct MirConnection MirConnection;
typedef struct MirSurface MirSurface;
typedef struct MirSurfaceSpec MirSurfaceSpec;
typedef struct MirScreencast MirScreencast;
typedef struct MirPromptSession MirPromptSession;
typedef struct MirBufferStream MirBufferStream;
typedef struct MirPersistentId MirPersistentId;
typedef struct MirBlob MirBlob;
typedef struct MirDisplayConfig MirDisplayConfig;


typedef struct xcb_connection_t xcb_connection_t;
typedef uint32_t xcb_window_t;
typedef uint32_t xcb_visualid_t;
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stdio.h" 2
# 5 "Base.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/stdlib.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stdlib.h" 2
# 6 "Base.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/string.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/string.h" 2
# 7 "Base.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/stddef.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stddef.h" 2
# 8 "Base.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/time.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/time.h" 2
# 9 "Base.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/setjmp.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/setjmp.h" 2
# 10 "Base.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/stdarg.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stdarg.h" 2
# 11 "Base.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/string.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/string.h" 2
# 12 "Base.h" 2
# 7 "UArray.c" 2


# 1 "UArray.h" 1
# 11 "UArray.h"
# 1 "Common.h" 1
# 13 "Common.h"
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/stdlib.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stdlib.h" 2
# 14 "Common.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/string.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/string.h" 2
# 15 "Common.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/stddef.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stddef.h" 2
# 16 "Common.h" 2







# 1 "/home/user/Development/Python/C/utils/fake_libc_include/stdint.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stdint.h" 2
# 24 "Common.h" 2
# 211 "Common.h"
 void *cpalloc(const void *p, size_t size);
 void *io_freerealloc(void *p, size_t size);

int io_isBigEndian(void);
 uint32_t io_uint32InBigEndian(uint32_t i);
# 12 "UArray.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/stdarg.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stdarg.h" 2
# 13 "UArray.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/stdio.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stdio.h" 2
# 14 "UArray.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/stddef.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stddef.h" 2
# 15 "UArray.h" 2






 typedef float float32_t;
 typedef double float64_t;


typedef size_t PID_TYPE;

typedef enum
{
 CTYPE_uint8_t,
 CTYPE_uint16_t,
 CTYPE_uint32_t,
 CTYPE_uint64_t,

 CTYPE_int8_t,
 CTYPE_int16_t,
 CTYPE_int32_t,
 CTYPE_int64_t,

 CTYPE_float32_t,
 CTYPE_float64_t,

 CTYPE_uintptr_t
} CTYPE;

typedef enum
{
 CENCODING_ASCII,
 CENCODING_UTF8,
 CENCODING_UCS2,
 CENCODING_UCS4,
 CENCODING_NUMBER
} CENCODING;

typedef struct
{
 uint8_t uint8;
 uint16_t uint16;
 uint32_t uint32;
 uint64_t uint64;
 int8_t int8;
 int16_t int16;
 int32_t int32;
 int64_t int64;
 float32_t float32;
 float64_t float64;
 uintptr_t uintptr;
} UArrayValueUnion;



typedef struct
{
 uint8_t *data;
 size_t size;
 CTYPE itemType;
 int itemSize;
 uintptr_t oddHash;
 uintptr_t evenHash;
 uint8_t encoding;

 int stackAllocated;

} UArray;

typedef UArray CharUArray;
typedef UArray PtrUArray;
typedef UArray FloatUArray;

 const void *UArray_data(const UArray *self);
 const uint8_t *UArray_bytes(const UArray *self);
 uint8_t *UArray_mutableBytes(UArray *self);
 const char *UArray_asCString(const UArray *self);

 size_t UArray_SizeOfCtype(CTYPE type);

 const char *CTYPE_name(CTYPE type);
 int CTYPE_forName(const char *name);
 int CTYPE_fixedWidthTextEncodingForType(CTYPE type);

 const char *CENCODING_name(CENCODING encoding);
 int CENCODING_forName(const char *name);
 int CENCODING_isText(CENCODING encoding);

 void UArray_unsupported_with_(const UArray *self, const char *methodName, const UArray *other);
 void UArray_error_(const UArray *self, char *e);

 UArray *UArray_new(void);
 UArray *UArray_newWithData_type_size_copy_(void *data, CTYPE type, size_t size, int copy);
 UArray *UArray_newWithData_type_encoding_size_copy_(void *bytes, CTYPE type, CENCODING encoding, size_t size, int copy);
 UArray *UArray_newWithCString_copy_(char *s, int copy);
 UArray *UArray_newWithCString_(const char *s);
 void UArray_setCString_(UArray *self, const char *s);
 void UArray_setData_type_size_copy_(UArray *self, void *data, CTYPE type, size_t size, int copy);
 UArray *UArray_clone(const UArray *self);
 void UArray_show(const UArray *self);
 void UArray_print(const UArray *self);

 UArray UArray_stackAllocedWithData_type_size_(void *data, CTYPE type, size_t size);
 UArray UArray_stackAllocedWithCString_(char *s);
 UArray UArray_stackAllocedEmptyUArray(void);

 void UArray_stackFree(UArray *self);
 void UArray_free(UArray *self);

 CTYPE UArray_itemType(const UArray *self);
 size_t UArray_itemSize(const UArray *self);
 void UArray_setItemType_(UArray *self, CTYPE type);
 CENCODING UArray_encoding(const UArray *self);
 void UArray_setEncoding_(UArray *self, CENCODING encoding);
 void UArray_convertToEncoding_(UArray *self, CENCODING encoding);



 void UArray_copyItems_(UArray *self, const UArray *other);
 void UArray_copy_(UArray *self, const UArray *other);
 void UArray_copyData_(UArray *self, const UArray *other);
 void UArray_convertToItemType_(UArray *self, CTYPE newItemType);






 void UArray_setSize_(UArray *self, size_t size);
 size_t UArray_size(const UArray *self);
 size_t UArray_sizeInBytes(const UArray *self);

 void UArray_sizeTo_(UArray *self, size_t size);



 UArray UArray_stackRange(const UArray *self, size_t start, size_t size);
 UArray *UArray_range(const UArray *self, size_t start, size_t size);
 UArray UArray_stackSlice(const UArray *self, long start, long end);
 UArray *UArray_slice(const UArray *self, long start, long end);



 int UArray_compare_(const UArray *self, const UArray *other);
 int UArray_equals_(const UArray *self, const UArray *other);
 int UArray_greaterThan_(const UArray *self, const UArray *other);
 int UArray_lessThan_(const UArray *self, const UArray *other);
 int UArray_greaterThanOrEqualTo_(const UArray *self, const UArray *other);
 int UArray_lessThanOrEqualTo_(const UArray *self, const UArray *other);
 int UArray_isZero(const UArray *self);



 int UArray_contains_(const UArray *self, const UArray *other);
 int UArray_containsAnyCase_(const UArray *self, const UArray *other);
 int UArray_containsDouble_(const UArray *self, double other);
 int UArray_containsLong_(const UArray *self, long other);



 long UArray_find_(const UArray *self, const UArray *other);
 long UArray_findAnyCase_(const UArray *self, const UArray *other);
 long UArray_find_from_(const UArray *self, const UArray *other, size_t from);
 long UArray_rFind_from_(const UArray *self, const UArray *other, size_t from);
 long UArray_rFind_(const UArray *self, const UArray *other);
 long UArray_rFindAnyCase_(const UArray *self, const UArray *other);
 long UArray_rFindAnyValue_(const UArray *self, const UArray *other);



 void UArray_at_putLong_(UArray *self, size_t pos, long v);
 void UArray_at_putDouble_(UArray *self, size_t pos, double v);
 void UArray_at_putPointer_(UArray *self, size_t pos, void *v);
 void UArray_at_putAll_(UArray *self, size_t pos, const UArray *other);

 void UArray_appendLong_(UArray *self, long v);
 void UArray_appendDouble_(UArray *self, double v);
 void UArray_appendPointer_(UArray *self, void *v);

 void UArray_appendBytes_size_(UArray *self, const uint8_t *bytes, size_t size);


 void UArray_insert_every_(UArray *self, UArray *other, size_t itemCount);



 void UArray_removeRange(UArray *self, size_t start, size_t size);
 void UArray_leave_thenRemove_(UArray *self, size_t itemsToLeave, size_t itemsToRemove);
 void UArray_removeFirst(UArray *self);
 void UArray_removeLast(UArray *self);
# 227 "UArray.h"
 void *UArray_rawPointerAt_(const UArray *self, size_t i);
 long UArray_rawLongAt_(const UArray *self, size_t i);
 double UArray_rawDoubleAt_(const UArray *self, size_t i);



 void *UArray_pointerAt_(const UArray *self, size_t i);
 long UArray_longAt_(const UArray *self, size_t i);
 double UArray_doubleAt_(const UArray *self, size_t i);



 long UArray_lastLong(const UArray *self);
 long UArray_firstLong(const UArray *self);



 int UArray_isFloatType(const UArray *self);
 int UArray_isSignedType(const UArray *self);

 size_t UArray_wrapPos_(const UArray *self, long pos);



 void UArray_sort(UArray *self);

typedef int (UArraySortCallback)(const void *, const void *);

 void UArray_sortBy_(UArray *self, UArraySortCallback *cmp);
# 488 "UArray.h"
# 1 "UArray_character.h" 1





 void UArray_isalnum(UArray *self);
 void UArray_isalpha(UArray *self);
 void UArray_iscntrl(UArray *self);
 void UArray_isdigit(UArray *self);
 void UArray_isgraph(UArray *self);
 void UArray_islower(UArray *self);
 void UArray_isprint(UArray *self);
 void UArray_ispunct(UArray *self);
 void UArray_isspace(UArray *self);
 void UArray_isupper(UArray *self);
 void UArray_isxdigit(UArray *self);
 void UArray_tolower(UArray *self);
 void UArray_toupper(UArray *self);

 int UArray_isLowercase(UArray *self);
 int UArray_isUppercase(UArray *self);
# 489 "UArray.h" 2
# 1 "UArray_format.h" 1





 UArray *UArray_newWithFormat_(const char *format, ...);
 UArray *UArray_newWithVargs_(const char *format, va_list ap);
 UArray *UArray_fromFormat_(UArray *self, const char *format, ...);
 void UArray_fromVargs_(UArray *self, const char *format, va_list ap);

 UArray *UArray_asNewHexStringUArray(UArray *self);
# 490 "UArray.h" 2
# 1 "UArray_math.h" 1







 void UArray_clear(UArray *self);
 void UArray_setItemsToLong_(UArray *self, long x);
 void UArray_setItemsToDouble_(UArray *self, double x);
 void UArray_rangeFill(UArray *self);
 void UArray_negate(const UArray *self);



 void UArray_add_(UArray *self, const UArray *other);
 void UArray_subtract_(UArray *self, const UArray *other);
 void UArray_multiply_(UArray *self, const UArray *other);
 void UArray_divide_(UArray *self, const UArray *other);
 double UArray_dotProduct_(const UArray *self, const UArray *other);



 void UArray_addScalarDouble_(UArray *self, double v);
 void UArray_subtractScalarDouble_(UArray *self, double v);
 void UArray_multiplyScalarDouble_(UArray *self, double v);
 void UArray_divideScalarDouble_(UArray *self, double v);
 void UArray_powerScalarDouble_(UArray *self, double v);



 void UArray_bitwiseOr_(UArray *self, const UArray *other);
 void UArray_bitwiseAnd_(UArray *self, const UArray *other);
 void UArray_bitwiseXor_(UArray *self, const UArray *other);
 void UArray_bitwiseNot(UArray *self);



 void UArray_setAllBitsTo_(UArray *self, uint8_t aBool);
 uint8_t UArray_byteAt_(UArray *self, size_t i);
 int UArray_bitAt_(UArray *self, size_t i);
 void UArray_setBit_at_(UArray *self, int b, size_t i);
 UArray * UArray_asBits(const UArray *self);
 size_t UArray_bitCount(UArray *self);



 void UArray_logicalOr_(UArray *self, const UArray *other);
 void UArray_logicalAnd_(UArray *self, const UArray *other);



 void UArray_sin(UArray *self);
 void UArray_cos(UArray *self);
 void UArray_tan(UArray *self);

 void UArray_asin(UArray *self);
 void UArray_acos(UArray *self);
 void UArray_atan(UArray *self);



 void UArray_sinh(UArray *self);
 void UArray_cosh(UArray *self);
 void UArray_tanh(UArray *self);

 void UArray_exp(UArray *self);
 void UArray_log(UArray *self);
 void UArray_log10(UArray *self);
 void UArray_power_(UArray *self, const UArray *other);

 void UArray_sqrt(UArray *self);
 void UArray_ceil(UArray *self);
 void UArray_floor(UArray *self);
 void UArray_abs(UArray *self);
 void UArray_round(UArray *self);




 void UArray_square(UArray *self);
 void UArray_normalize(UArray *self);

 void UArray_crossProduct_(UArray *self, const UArray *other);
 double UArray_distanceTo_(const UArray *self, const UArray *other);



 double UArray_sumAsDouble(const UArray *self);
 double UArray_productAsDouble(const UArray *self);
 double UArray_arithmeticMeanAsDouble(const UArray *self);
 double UArray_arithmeticMeanSquareAsDouble(const UArray *self);
 double UArray_maxAsDouble(const UArray *self);
 double UArray_minAsDouble(const UArray *self);
 void UArray_Max(UArray *self, const UArray *other);
 void UArray_Min(UArray *self, const UArray *other);



 void UArray_changed(UArray *self);
 uintptr_t UArray_calcHash(UArray *self);
 uintptr_t UArray_evenHash(UArray *self);
 uintptr_t UArray_oddHash(UArray *self);

 int UArray_equalsWithHashCheck_(UArray *self, UArray *other);



 void UArray_duplicateIndexes(UArray *self);
 void UArray_removeOddIndexes(UArray *self);
 void UArray_removeEvenIndexes(UArray *self);

 void UArray_reverseItemByteOrders(UArray *self);

 void UArray_addEqualsOffsetXScaleYScale(UArray *self, UArray *other, float offset, float xscale, float yscale);
# 491 "UArray.h" 2
# 1 "UArray_path.h" 1
# 27 "UArray_path.h"
 void UArray_appendPath_(UArray *self, const UArray *path);



 void UArray_removeLastPathComponent(UArray *self);
 void UArray_clipBeforeLastPathComponent(UArray *self);
 long UArray_findLastPathComponent(const UArray *self);
 UArray *UArray_lastPathComponent(const UArray *self);



 long UArray_findPathExtension(UArray *self);
 void UArray_removePathExtension(UArray *self);
 UArray *UArray_pathExtension(UArray *self);



 UArray *UArray_fileName(UArray *self);



 int UArray_OSPathSeparatorIsUnixSeparator(void);
 UArray *UArray_asOSPath(UArray *self);
 UArray *UArray_asUnixPath(UArray *self);
# 492 "UArray.h" 2
# 1 "UArray_stream.h" 1
# 10 "UArray_stream.h"
 size_t UArray_fread_(UArray *self, FILE *fp);
 long UArray_readFromCStream_(UArray *self, FILE *stream);
 long UArray_readFromFilePath_(UArray *self, const UArray *path);
 long UArray_readNumberOfItems_fromCStream_(UArray *self, size_t size, FILE *stream);
 int UArray_readLineFromCStream_(UArray *self, FILE *stream);



 size_t UArray_fwrite_(const UArray *self, size_t size, FILE *stream);
 long UArray_writeToCStream_(const UArray *self, FILE *stream);
 long UArray_writeToFilePath_(const UArray *self, const UArray *path);
# 493 "UArray.h" 2
# 1 "UArray_string.h" 1
# 11 "UArray_string.h"
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/string.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/string.h" 2
# 12 "UArray_string.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/stdarg.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stdarg.h" 2
# 13 "UArray_string.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/stdio.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stdio.h" 2
# 14 "UArray_string.h" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/stddef.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stddef.h" 2
# 15 "UArray_string.h" 2

 void UArray_append_(UArray *self, const UArray *other);
 void UArray_appendCString_(UArray *self, const char *s);
 void UArray_prepend_(UArray *self, const UArray *other);

 int UArray_equalsAnyCase_(const UArray *self, const UArray *other);
 void UArray_replace_with_(UArray *self, const UArray *a1, const UArray *a2);
 void UArray_replaceAnyCase_with_(UArray *self, const UArray *a1, const UArray *a2);
 void UArray_replaceCString_withCString_(UArray *self, const char *s1, const char *s2);
 void UArray_remove_(UArray *self, const UArray *a1);
 void UArray_removeAnyCase_(UArray *self, const UArray *a1);



 int UArray_clipBefore_(UArray *self, const UArray *other);
 int UArray_clipBeforeEndOf_(UArray *self, const UArray *other);
 int UArray_clipAfter_(UArray *self, const UArray *other);
 int UArray_clipAfterStartOf_(UArray *self, const UArray *other);



 void UArray_lstrip_(UArray *self, const UArray *other);
 void UArray_rstrip_(UArray *self, const UArray *other);
 void UArray_strip_(UArray *self, const UArray *other);



 void UArray_swapIndex_withIndex_(UArray *self, size_t i, size_t j);



 void UArray_reverse(UArray *self);





 PtrUArray *UArray_split_(const UArray *self, const PtrUArray *delims);
 size_t UArray_splitCount_(const UArray *self, const PtrUArray *delims);



 int UArray_beginsWith_(UArray *self, const UArray *other);
 int UArray_endsWith_(UArray *self, const UArray *other);



 void UArray_swapWith_(UArray *self, UArray *other);

 void UArray_escape(UArray *self);
 void UArray_unescape(UArray *self);

 void UArray_quote(UArray *self);
 void UArray_unquote(UArray *self);

 void UArray_translate(UArray *self, UArray *fromChars, UArray *toChars);
 size_t UArray_count_(const UArray *self, const UArray *other);



 UArray* UArray_asBase64(const UArray *self, int charsPerLine);
 UArray* UArray_fromBase64(const UArray *self);
# 494 "UArray.h" 2
# 1 "UArray_utf.h" 1





 int UArray_convertToFixedSizeType(UArray *self);

 size_t UArray_numberOfCharacters(const UArray *self);

 int UArray_maxCharSize(const UArray *self);
 int UArray_isMultibyte(const UArray *self);
 int UArray_isLegalUTF8(const UArray *self);

 UArray *UArray_asUTF8(const UArray *self);
 UArray *UArray_asUCS2(const UArray *self);
 UArray *UArray_asUCS4(const UArray *self);

 void UArray_convertToUTF8(UArray *self);
 void UArray_convertToUCS2(UArray *self);
 void UArray_convertToUCS4(UArray *self);
# 495 "UArray.h" 2
# 10 "UArray.c" 2


# 1 "/home/user/Development/Python/C/utils/fake_libc_include/string.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/string.h" 2
# 13 "UArray.c" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/ctype.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/ctype.h" 2
# 14 "UArray.c" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/stdlib.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/stdlib.h" 2
# 15 "UArray.c" 2
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/limits.h" 1
# 1 "/home/user/Development/Python/C/utils/fake_libc_include/_fake_defines.h" 1
# 2 "/home/user/Development/Python/C/utils/fake_libc_include/limits.h" 2
# 16 "UArray.c" 2

size_t CTYPE_size(CTYPE type)
{
 switch (type)
 {
  case CTYPE_uint8_t: return sizeof(uint8_t);
  case CTYPE_uint16_t: return sizeof(uint16_t);
  case CTYPE_uint32_t: return sizeof(uint32_t);
  case CTYPE_uint64_t: return sizeof(uint64_t);

  case CTYPE_int8_t: return sizeof(int8_t);
  case CTYPE_int16_t: return sizeof(int16_t);
  case CTYPE_int32_t: return sizeof(int32_t);
  case CTYPE_int64_t: return sizeof(int64_t);

  case CTYPE_float32_t: return sizeof(float32_t);
  case CTYPE_float64_t: return sizeof(float64_t);

  case CTYPE_uintptr_t: return sizeof(uintptr_t);
 }
 return 0;
}

const char *CTYPE_name(CTYPE type)
{
 switch (type)
 {
  case CTYPE_uint8_t: return "uint8";
  case CTYPE_uint16_t: return "uint16";
  case CTYPE_uint32_t: return "uint32";
  case CTYPE_uint64_t: return "uint64";

  case CTYPE_int8_t: return "int8";
  case CTYPE_int16_t: return "int16";
  case CTYPE_int32_t: return "int32";
  case CTYPE_int64_t: return "int64";

  case CTYPE_float32_t: return "float32";
  case CTYPE_float64_t: return "float64";

  case CTYPE_uintptr_t: return "intptr";
 }
 return "unknown";
}

int CTYPE_forName(const char *name)
{
 if(!strcmp(name, "uint8")) return CTYPE_uint8_t;
 if(!strcmp(name, "uint16")) return CTYPE_uint16_t;
 if(!strcmp(name, "uint32")) return CTYPE_uint32_t;
 if(!strcmp(name, "uint64")) return CTYPE_uint64_t;
 if(!strcmp(name, "int8")) return CTYPE_int8_t;
 if(!strcmp(name, "int16")) return CTYPE_int16_t;
 if(!strcmp(name, "int32")) return CTYPE_int32_t;
 if(!strcmp(name, "int64")) return CTYPE_int64_t;
 if(!strcmp(name, "float32")) return CTYPE_float32_t;
 if(!strcmp(name, "float64")) return CTYPE_float64_t;
 return -1;
}

int CTYPE_fixedWidthTextEncodingForType(CTYPE type)
{
 if(type == CTYPE_int8_t) return CENCODING_ASCII;
 if(type == CTYPE_uint16_t) return CENCODING_UCS2;
 if(type == CTYPE_uint32_t) return CENCODING_UCS4;
 return -1;
}

int CENCODING_forName(const char *name)
{
 if(!strcmp(name, "ascii")) return CENCODING_ASCII;
 if(!strcmp(name, "utf8")) return CENCODING_UTF8;
 if(!strcmp(name, "ucs2")) return CENCODING_UCS2;
 if(!strcmp(name, "ucs4")) return CENCODING_UCS4;
 if(!strcmp(name, "number")) return CENCODING_NUMBER;
 return -1;
}

int CENCODING_isText(CENCODING encoding)
{
 return encoding != CENCODING_NUMBER;
}

const char *CENCODING_name(CENCODING encoding)
{
 switch (encoding)
 {
  case CENCODING_ASCII: return "ascii";
  case CENCODING_UTF8: return "utf8";
  case CENCODING_UCS2: return "ucs2";
  case CENCODING_UCS4: return "ucs4";
  case CENCODING_NUMBER: return "number";
 }
 return "unknown";
}



void UArray_unsupported_with_(const UArray *self, const char *methodName, const UArray *other)
{

 printf("Error: '%s' not supported between '%s' and '%s'\n",
     methodName, CTYPE_name(self->itemType), CTYPE_name(other->itemType));
 exit(-1);
}

void UArray_error_(const UArray *self, char *e)
{
 printf("%s\n", e);
 exit(-1);
}



CTYPE UArray_itemType(const UArray *self)
{
 return self->itemType;
}

size_t UArray_itemSize(const UArray *self)
{
 return self->itemSize;
}


size_t UArray_sizeRequiredToContain_(const UArray *self, const UArray *other)
{
 return (UArray_sizeInBytes(other) + self->itemSize - 1) / self->itemSize;
}

void UArray_rawSetItemType_(UArray *self, CTYPE type)
{
 int itemSize = (int)CTYPE_size(type);
 self->itemType = type;
 self->itemSize = itemSize;
}

void UArray_setItemType_(UArray *self, CTYPE type)
{
 int itemSize = (int)CTYPE_size(type);
 div_t q = div((int)UArray_sizeInBytes(self), (int)itemSize);

 if (q.rem != 0)
 {
  q.quot += 1;
  UArray_setSize_(self, (q.quot * itemSize) / self->itemSize);
 }

 self->itemType = type;

 self->itemSize = itemSize;
 self->size = q.quot;



 if (UArray_isFloatType(self))
 {
  self->encoding = CENCODING_NUMBER;
 }
 else if (self->encoding == CENCODING_ASCII)
 {
  switch(self->itemSize)
  {
   case 2: self->encoding = CENCODING_UCS2; break;
   case 4: self->encoding = CENCODING_UCS4; break;
   case 8: self->encoding = CENCODING_NUMBER; break;
  }
 }
}

CENCODING UArray_encoding(const UArray *self)
{
 return self->encoding;
}

void UArray_setEncoding_(UArray *self, CENCODING encoding)
{


 switch(encoding)
 {
  case CENCODING_ASCII:
  case CENCODING_UTF8:
   UArray_setItemType_(self, CTYPE_uint8_t);
   break;
  case CENCODING_UCS2:
   UArray_setItemType_(self, CTYPE_uint16_t);
   break;
  case CENCODING_UCS4:
   UArray_setItemType_(self, CTYPE_uint32_t);
   break;
  case CENCODING_NUMBER:



   break;
 }

 self->encoding = encoding;
}

void UArray_convertToEncoding_(UArray *self, CENCODING encoding)
{
 switch(encoding)
 {
  case CENCODING_ASCII:
  case CENCODING_UTF8:
   UArray_convertToUTF8(self);
   break;
  case CENCODING_UCS2:
   UArray_convertToUCS2(self);
   break;
  case CENCODING_UCS4:
   UArray_convertToUCS4(self);
   break;
  case CENCODING_NUMBER:
   UArray_setItemType_(self, CTYPE_uint8_t);
   break;
 }

 self->encoding = encoding;
 UArray_changed(self);
}

UArray *UArray_newWithData_type_encoding_size_copy_(void *bytes, CTYPE type, CENCODING encoding, size_t size, int copy)
{
 UArray *self = (UArray *)calloc(1, sizeof(UArray));
 UArray_setData_type_size_copy_(self, bytes, type, size, copy);
 self->encoding = encoding;
 return self;
}

UArray *UArray_newWithData_type_size_copy_(void *bytes, CTYPE type, size_t size, int copy)
{
 UArray *self = (UArray *)calloc(1, sizeof(UArray));
 UArray_setData_type_size_copy_(self, bytes, type, size, copy);
 self->encoding = CENCODING_ASCII;
 return self;
}

UArray *UArray_new(void)
{
 return UArray_newWithData_type_size_copy_("", CTYPE_uint8_t, 0, 1);
}

UArray *UArray_clone(const UArray *self)
{
 UArray *out = UArray_new();
 UArray_copy_(out, self);
 return out;
}

void UArray_show(const UArray *self)
{
 printf("UArray_%p %s\t", (void *)self, CTYPE_name(self->itemType));
 printf("size: %i ", (int)self->size);
 printf("itemSize: %i ", (int)self->itemSize);
 printf("data: ");
 UArray_print(self);
 printf("\n");
}

void UArray_print(const UArray *self)
{
 if(self->encoding == CENCODING_ASCII || self->encoding == CENCODING_UTF8)
 {
  fwrite(self->data, self->itemSize, self->size, stdout);
 }
 else if(self->encoding != CENCODING_NUMBER)
 {
  switch(self->itemType) { case CTYPE_uint8_t: { size_t i; for(i = 0; i < self->size; i ++) { uint8_t v = ((uint8_t *)self->data)[i]; printf("%c", (int)v);; } }; break;; case CTYPE_uint16_t: { size_t i; for(i = 0; i < self->size; i ++) { uint16_t v = ((uint16_t *)self->data)[i]; printf("%c", (int)v);; } }; break;; case CTYPE_uint32_t: { size_t i; for(i = 0; i < self->size; i ++) { uint32_t v = ((uint32_t *)self->data)[i]; printf("%c", (int)v);; } }; break;; case CTYPE_uint64_t: { size_t i; for(i = 0; i < self->size; i ++) { uint64_t v = ((uint64_t *)self->data)[i]; printf("%c", (int)v);; } }; break;; case CTYPE_int8_t: { size_t i; for(i = 0; i < self->size; i ++) { int8_t v = ((int8_t *)self->data)[i]; printf("%c", (int)v);; } }; break;; case CTYPE_int16_t: { size_t i; for(i = 0; i < self->size; i ++) { int16_t v = ((int16_t *)self->data)[i]; printf("%c", (int)v);; } }; break;; case CTYPE_int32_t: { size_t i; for(i = 0; i < self->size; i ++) { int32_t v = ((int32_t *)self->data)[i]; printf("%c", (int)v);; } }; break;; case CTYPE_int64_t: { size_t i; for(i = 0; i < self->size; i ++) { int64_t v = ((int64_t *)self->data)[i]; printf("%c", (int)v);; } }; break;; case CTYPE_float32_t: { size_t i; for(i = 0; i < self->size; i ++) { float32_t v = ((float32_t *)self->data)[i]; printf("%c", (int)v);; } }; break;; case CTYPE_float64_t: { size_t i; for(i = 0; i < self->size; i ++) { float64_t v = ((float64_t *)self->data)[i]; printf("%c", (int)v);; } }; break;; case CTYPE_uintptr_t: { size_t i; for(i = 0; i < self->size; i ++) { uintptr_t v = ((uintptr_t *)self->data)[i]; printf("%c", (int)v);; } }; break;; };
 }
 else if(UArray_isFloatType(self))
 {
  printf("[");
  switch(self->itemType) { case CTYPE_uint8_t: { size_t i; for(i = 0; i < self->size; i ++) { uint8_t v = ((uint8_t *)self->data)[i]; printf("%f", (float)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_uint16_t: { size_t i; for(i = 0; i < self->size; i ++) { uint16_t v = ((uint16_t *)self->data)[i]; printf("%f", (float)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_uint32_t: { size_t i; for(i = 0; i < self->size; i ++) { uint32_t v = ((uint32_t *)self->data)[i]; printf("%f", (float)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_uint64_t: { size_t i; for(i = 0; i < self->size; i ++) { uint64_t v = ((uint64_t *)self->data)[i]; printf("%f", (float)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_int8_t: { size_t i; for(i = 0; i < self->size; i ++) { int8_t v = ((int8_t *)self->data)[i]; printf("%f", (float)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_int16_t: { size_t i; for(i = 0; i < self->size; i ++) { int16_t v = ((int16_t *)self->data)[i]; printf("%f", (float)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_int32_t: { size_t i; for(i = 0; i < self->size; i ++) { int32_t v = ((int32_t *)self->data)[i]; printf("%f", (float)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_int64_t: { size_t i; for(i = 0; i < self->size; i ++) { int64_t v = ((int64_t *)self->data)[i]; printf("%f", (float)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_float32_t: { size_t i; for(i = 0; i < self->size; i ++) { float32_t v = ((float32_t *)self->data)[i]; printf("%f", (float)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_float64_t: { size_t i; for(i = 0; i < self->size; i ++) { float64_t v = ((float64_t *)self->data)[i]; printf("%f", (float)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_uintptr_t: { size_t i; for(i = 0; i < self->size; i ++) { uintptr_t v = ((uintptr_t *)self->data)[i]; printf("%f", (float)v); if(i != self->size - 1) printf(", ");; } }; break;; }


      ;
  printf("]");
 }
 else
 {
  printf("[");
  switch(self->itemType) { case CTYPE_uint8_t: { size_t i; for(i = 0; i < self->size; i ++) { uint8_t v = ((uint8_t *)self->data)[i]; printf("%i", (int)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_uint16_t: { size_t i; for(i = 0; i < self->size; i ++) { uint16_t v = ((uint16_t *)self->data)[i]; printf("%i", (int)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_uint32_t: { size_t i; for(i = 0; i < self->size; i ++) { uint32_t v = ((uint32_t *)self->data)[i]; printf("%i", (int)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_uint64_t: { size_t i; for(i = 0; i < self->size; i ++) { uint64_t v = ((uint64_t *)self->data)[i]; printf("%i", (int)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_int8_t: { size_t i; for(i = 0; i < self->size; i ++) { int8_t v = ((int8_t *)self->data)[i]; printf("%i", (int)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_int16_t: { size_t i; for(i = 0; i < self->size; i ++) { int16_t v = ((int16_t *)self->data)[i]; printf("%i", (int)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_int32_t: { size_t i; for(i = 0; i < self->size; i ++) { int32_t v = ((int32_t *)self->data)[i]; printf("%i", (int)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_int64_t: { size_t i; for(i = 0; i < self->size; i ++) { int64_t v = ((int64_t *)self->data)[i]; printf("%i", (int)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_float32_t: { size_t i; for(i = 0; i < self->size; i ++) { float32_t v = ((float32_t *)self->data)[i]; printf("%i", (int)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_float64_t: { size_t i; for(i = 0; i < self->size; i ++) { float64_t v = ((float64_t *)self->data)[i]; printf("%i", (int)v); if(i != self->size - 1) printf(", ");; } }; break;; case CTYPE_uintptr_t: { size_t i; for(i = 0; i < self->size; i ++) { uintptr_t v = ((uintptr_t *)self->data)[i]; printf("%i", (int)v); if(i != self->size - 1) printf(", ");; } }; break;; }


      ;
  printf("]");
 }
}

UArray UArray_stackAllocedWithData_type_size_(void *data, CTYPE type, size_t size)
{
 UArray self;
 memset(&self, 0, sizeof(UArray));


 self.stackAllocated = 1;


 self.itemType = type;
 self.itemSize = (int)CTYPE_size(type);
 self.size = size;
 self.data = data;
 return self;
}

 UArray UArray_stackAllocedEmptyUArray(void)
{
 UArray self;
 memset(&self, 0, sizeof(UArray));


 self.stackAllocated = 1;


 self.itemType = CTYPE_int32_t;
 self.itemSize = 4;
 self.size = 0;
 self.data = 0x0;
 return self;
}

UArray *UArray_newWithCString_copy_(char *s, int copy)
{
 return UArray_newWithData_type_size_copy_(s, CTYPE_uint8_t, strlen(s), copy);
}

UArray *UArray_newWithCString_(const char *s)
{
 return UArray_newWithData_type_size_copy_((uint8_t *)s, CTYPE_uint8_t, strlen(s), 1);
}

void UArray_empty(UArray *self)
{
 UArray_setSize_(self, 0);
}

void UArray_setCString_(UArray *self, const char *s)
{
 UArray_empty(self);
 UArray_setItemType_(self, CTYPE_uint8_t);
 UArray_appendCString_(self, s);
}


void UArray_checkIfOkToRelloc(UArray *self)
{
 if(self->stackAllocated)
 {
  printf("UArray debug error: attempt to io_realloc UArray data that this UArray does not own");
  exit(-1);
 }
}


void UArray_setData_type_size_copy_(UArray *self, void *data, CTYPE type, size_t size, int copy)
{
 size_t sizeInBytes;

 UArray_rawSetItemType_(self, type);
 self->size = size;

 sizeInBytes = self->size * self->itemSize;


 UArray_checkIfOkToRelloc(self);


 if (copy)
 {
  self->data = io_freerealloc(self->data, sizeInBytes + 1);
  memmove(self->data, data, sizeInBytes);
  self->data[sizeInBytes] = 0x0;
 }
 else
 {
  if(self->data) free(self->data);
  self->data = data;
 }

}

UArray UArray_stackAllocedWithCString_(char *s)
{
 return UArray_stackAllocedWithData_type_size_(s, CTYPE_uint8_t, strlen(s));
}

const void *UArray_data(const UArray *self)
{
 return self->data;
}

const uint8_t *UArray_bytes(const UArray *self)
{
 return self->data;
}

uint8_t *UArray_mutableBytes(UArray *self)
{
 UArray_changed(self);
 return self->data;
}

const char *UArray_asCString(const UArray *self)
{
 return (const char *)(self->data);
}

void UArray_stackFree(UArray *self)
{
 if(self->data) free(self->data);
}

void UArray_free(UArray *self)
{
 if(self->data) free(self->data);
 free(self);
}



void UArray_setSize_(UArray *self, size_t size)
{
 if (size != self->size)
 {
  size_t oldSizeInBytes = UArray_sizeInBytes(self);
  size_t newSizeInBytes = self->itemSize * size;


   UArray_checkIfOkToRelloc(self);

  self->data = io_freerealloc(self->data, newSizeInBytes + 1);


  self->data[newSizeInBytes] = 0x0;
  self->size = size;

  if (newSizeInBytes > oldSizeInBytes)
  {
   memset(self->data + oldSizeInBytes, 0, newSizeInBytes - oldSizeInBytes);
  }

  UArray_changed(self);
 }
}

size_t UArray_size(const UArray *self)
{
 return self->size;
}

size_t UArray_sizeInBytes(const UArray *self)
{
 return self->size * self->itemSize;
}

void UArray_sizeTo_(UArray *self, size_t size)
{
 UArray_setSize_(self, size);
}



void UArray_copy_(UArray *self, const UArray *other)
{
 UArray_setItemType_(self, UArray_itemType(other));
 UArray_setEncoding_(self, UArray_encoding(other));
 UArray_setSize_(self, UArray_size(other));
 UArray_copyItems_(self, other);
}

void UArray_copyItems_(UArray *self, const UArray *other)
{
 if(self->size != other->size)
 {
  printf("UArray_copyItems_ error - arrays not of same size\n");
  exit(-1);
 }

 if(self->itemType == other->itemType)
 {
  UArray_copyData_(self, other);
 }
 else
 {
  switch (self->itemType) { case CTYPE_uint8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint8_t *)self->data)[i] = (uint8_t)((uint8_t *)other->data)[i]; } return; }; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint8_t *)self->data)[i] = (uint8_t)((uint16_t *)other->data)[i]; } return; }; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint8_t *)self->data)[i] = (uint8_t)((uint32_t *)other->data)[i]; } return; }; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint8_t *)self->data)[i] = (uint8_t)((uint64_t *)other->data)[i]; } return; }; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint8_t *)self->data)[i] = (uint8_t)((int8_t *)other->data)[i]; } return; }; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint8_t *)self->data)[i] = (uint8_t)((int16_t *)other->data)[i]; } return; }; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint8_t *)self->data)[i] = (uint8_t)((int32_t *)other->data)[i]; } return; }; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint8_t *)self->data)[i] = (uint8_t)((int64_t *)other->data)[i]; } return; }; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint8_t *)self->data)[i] = (uint8_t)((float32_t *)other->data)[i]; } return; }; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint8_t *)self->data)[i] = (uint8_t)((float64_t *)other->data)[i]; } return; }; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint8_t *)self->data)[i] = (uint8_t)((uintptr_t *)other->data)[i]; } return; }; break; }; case CTYPE_uint16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint16_t *)self->data)[i] = (uint16_t)((uint8_t *)other->data)[i]; } return; }; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint16_t *)self->data)[i] = (uint16_t)((uint16_t *)other->data)[i]; } return; }; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint16_t *)self->data)[i] = (uint16_t)((uint32_t *)other->data)[i]; } return; }; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint16_t *)self->data)[i] = (uint16_t)((uint64_t *)other->data)[i]; } return; }; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint16_t *)self->data)[i] = (uint16_t)((int8_t *)other->data)[i]; } return; }; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint16_t *)self->data)[i] = (uint16_t)((int16_t *)other->data)[i]; } return; }; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint16_t *)self->data)[i] = (uint16_t)((int32_t *)other->data)[i]; } return; }; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint16_t *)self->data)[i] = (uint16_t)((int64_t *)other->data)[i]; } return; }; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint16_t *)self->data)[i] = (uint16_t)((float32_t *)other->data)[i]; } return; }; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint16_t *)self->data)[i] = (uint16_t)((float64_t *)other->data)[i]; } return; }; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint16_t *)self->data)[i] = (uint16_t)((uintptr_t *)other->data)[i]; } return; }; break; }; case CTYPE_uint32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((uint8_t *)other->data)[i]; } return; }; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((uint16_t *)other->data)[i]; } return; }; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((uint32_t *)other->data)[i]; } return; }; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((uint64_t *)other->data)[i]; } return; }; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((int8_t *)other->data)[i]; } return; }; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((int16_t *)other->data)[i]; } return; }; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((int32_t *)other->data)[i]; } return; }; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((int64_t *)other->data)[i]; } return; }; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((float32_t *)other->data)[i]; } return; }; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((float64_t *)other->data)[i]; } return; }; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((uintptr_t *)other->data)[i]; } return; }; break; }; case CTYPE_uint64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((uint8_t *)other->data)[i]; } return; }; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((uint16_t *)other->data)[i]; } return; }; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((uint32_t *)other->data)[i]; } return; }; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((uint64_t *)other->data)[i]; } return; }; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((int8_t *)other->data)[i]; } return; }; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((int16_t *)other->data)[i]; } return; }; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((int32_t *)other->data)[i]; } return; }; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((int64_t *)other->data)[i]; } return; }; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((float32_t *)other->data)[i]; } return; }; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((float64_t *)other->data)[i]; } return; }; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((uintptr_t *)other->data)[i]; } return; }; break; }; case CTYPE_int8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int8_t *)self->data)[i] = (int8_t)((uint8_t *)other->data)[i]; } return; }; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int8_t *)self->data)[i] = (int8_t)((uint16_t *)other->data)[i]; } return; }; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int8_t *)self->data)[i] = (int8_t)((uint32_t *)other->data)[i]; } return; }; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int8_t *)self->data)[i] = (int8_t)((uint64_t *)other->data)[i]; } return; }; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int8_t *)self->data)[i] = (int8_t)((int8_t *)other->data)[i]; } return; }; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int8_t *)self->data)[i] = (int8_t)((int16_t *)other->data)[i]; } return; }; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int8_t *)self->data)[i] = (int8_t)((int32_t *)other->data)[i]; } return; }; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int8_t *)self->data)[i] = (int8_t)((int64_t *)other->data)[i]; } return; }; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int8_t *)self->data)[i] = (int8_t)((float32_t *)other->data)[i]; } return; }; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int8_t *)self->data)[i] = (int8_t)((float64_t *)other->data)[i]; } return; }; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int8_t *)self->data)[i] = (int8_t)((uintptr_t *)other->data)[i]; } return; }; break; }; case CTYPE_int16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int16_t *)self->data)[i] = (int16_t)((uint8_t *)other->data)[i]; } return; }; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int16_t *)self->data)[i] = (int16_t)((uint16_t *)other->data)[i]; } return; }; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int16_t *)self->data)[i] = (int16_t)((uint32_t *)other->data)[i]; } return; }; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int16_t *)self->data)[i] = (int16_t)((uint64_t *)other->data)[i]; } return; }; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int16_t *)self->data)[i] = (int16_t)((int8_t *)other->data)[i]; } return; }; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int16_t *)self->data)[i] = (int16_t)((int16_t *)other->data)[i]; } return; }; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int16_t *)self->data)[i] = (int16_t)((int32_t *)other->data)[i]; } return; }; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int16_t *)self->data)[i] = (int16_t)((int64_t *)other->data)[i]; } return; }; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int16_t *)self->data)[i] = (int16_t)((float32_t *)other->data)[i]; } return; }; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int16_t *)self->data)[i] = (int16_t)((float64_t *)other->data)[i]; } return; }; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((int16_t *)self->data)[i] = (int16_t)((uintptr_t *)other->data)[i]; } return; }; break; }; case CTYPE_int32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((uint8_t *)other->data)[i]; } return; }; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((uint16_t *)other->data)[i]; } return; }; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((uint32_t *)other->data)[i]; } return; }; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((uint64_t *)other->data)[i]; } return; }; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((int8_t *)other->data)[i]; } return; }; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((int16_t *)other->data)[i]; } return; }; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((int32_t *)other->data)[i]; } return; }; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((int64_t *)other->data)[i]; } return; }; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((float32_t *)other->data)[i]; } return; }; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((float64_t *)other->data)[i]; } return; }; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint32_t *)self->data)[i] = (uint32_t)((uintptr_t *)other->data)[i]; } return; }; break; }; case CTYPE_int64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((uint8_t *)other->data)[i]; } return; }; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((uint16_t *)other->data)[i]; } return; }; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((uint32_t *)other->data)[i]; } return; }; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((uint64_t *)other->data)[i]; } return; }; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((int8_t *)other->data)[i]; } return; }; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((int16_t *)other->data)[i]; } return; }; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((int32_t *)other->data)[i]; } return; }; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((int64_t *)other->data)[i]; } return; }; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((float32_t *)other->data)[i]; } return; }; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((float64_t *)other->data)[i]; } return; }; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uint64_t *)self->data)[i] = (uint64_t)((uintptr_t *)other->data)[i]; } return; }; break; }; case CTYPE_float32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float32_t *)self->data)[i] = (float32_t)((uint8_t *)other->data)[i]; } return; }; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float32_t *)self->data)[i] = (float32_t)((uint16_t *)other->data)[i]; } return; }; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float32_t *)self->data)[i] = (float32_t)((uint32_t *)other->data)[i]; } return; }; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float32_t *)self->data)[i] = (float32_t)((uint64_t *)other->data)[i]; } return; }; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float32_t *)self->data)[i] = (float32_t)((int8_t *)other->data)[i]; } return; }; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float32_t *)self->data)[i] = (float32_t)((int16_t *)other->data)[i]; } return; }; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float32_t *)self->data)[i] = (float32_t)((int32_t *)other->data)[i]; } return; }; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float32_t *)self->data)[i] = (float32_t)((int64_t *)other->data)[i]; } return; }; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float32_t *)self->data)[i] = (float32_t)((float32_t *)other->data)[i]; } return; }; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float32_t *)self->data)[i] = (float32_t)((float64_t *)other->data)[i]; } return; }; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float32_t *)self->data)[i] = (float32_t)((uintptr_t *)other->data)[i]; } return; }; break; }; case CTYPE_float64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float64_t *)self->data)[i] = (float64_t)((uint8_t *)other->data)[i]; } return; }; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float64_t *)self->data)[i] = (float64_t)((uint16_t *)other->data)[i]; } return; }; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float64_t *)self->data)[i] = (float64_t)((uint32_t *)other->data)[i]; } return; }; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float64_t *)self->data)[i] = (float64_t)((uint64_t *)other->data)[i]; } return; }; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float64_t *)self->data)[i] = (float64_t)((int8_t *)other->data)[i]; } return; }; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float64_t *)self->data)[i] = (float64_t)((int16_t *)other->data)[i]; } return; }; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float64_t *)self->data)[i] = (float64_t)((int32_t *)other->data)[i]; } return; }; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float64_t *)self->data)[i] = (float64_t)((int64_t *)other->data)[i]; } return; }; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float64_t *)self->data)[i] = (float64_t)((float32_t *)other->data)[i]; } return; }; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float64_t *)self->data)[i] = (float64_t)((float64_t *)other->data)[i]; } return; }; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((float64_t *)self->data)[i] = (float64_t)((uintptr_t *)other->data)[i]; } return; }; break; }; case CTYPE_uintptr_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uintptr_t *)self->data)[i] = (uintptr_t)((uint8_t *)other->data)[i]; } return; }; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uintptr_t *)self->data)[i] = (uintptr_t)((uint16_t *)other->data)[i]; } return; }; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uintptr_t *)self->data)[i] = (uintptr_t)((uint32_t *)other->data)[i]; } return; }; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uintptr_t *)self->data)[i] = (uintptr_t)((uint64_t *)other->data)[i]; } return; }; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uintptr_t *)self->data)[i] = (uintptr_t)((int8_t *)other->data)[i]; } return; }; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uintptr_t *)self->data)[i] = (uintptr_t)((int16_t *)other->data)[i]; } return; }; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uintptr_t *)self->data)[i] = (uintptr_t)((int32_t *)other->data)[i]; } return; }; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uintptr_t *)self->data)[i] = (uintptr_t)((int64_t *)other->data)[i]; } return; }; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uintptr_t *)self->data)[i] = (uintptr_t)((float32_t *)other->data)[i]; } return; }; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uintptr_t *)self->data)[i] = (uintptr_t)((float64_t *)other->data)[i]; } return; }; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { ((uintptr_t *)self->data)[i] = (uintptr_t)((uintptr_t *)other->data)[i]; } return; }; break; }; }; UArray_unsupported_with_(self, "=", other);;
 }

 UArray_changed(self);
}

void UArray_copyData_(UArray *self, const UArray *other)
{
 UArray_setSize_(self, UArray_sizeRequiredToContain_(self, other));
 memmove(self->data, other->data, UArray_sizeInBytes(other));
}

void UArray_convertToItemType_(UArray *self, CTYPE newItemType)
{
 if (self->itemType != newItemType)
 {
  UArray *tmp = UArray_new();
  CENCODING encoding = UArray_encoding(self);
  UArray_setItemType_(tmp, newItemType);

  if(CENCODING_isText(self->encoding))
  {
   encoding = CTYPE_fixedWidthTextEncodingForType(newItemType);
  }

  UArray_setEncoding_(tmp, encoding);
  UArray_setSize_(tmp, self->size);
  UArray_copyItems_(tmp, self);
  UArray_copy_(self, tmp);
  UArray_free(tmp);
  UArray_changed(self);
 }
}



UArray UArray_stackRange(const UArray *self, size_t start, size_t size)
{
 UArray s;

 memcpy(&s, self, sizeof(UArray));
 UArray_changed(&s);


 s.stackAllocated = 1;


 if(start < self->size || start == 0)
 {
  s.data = self->data + self->itemSize * start;
 }
 else
 {
  s.data = 0x0;
 }

 if(start + size <= self->size)
 {
  s.size = size;
 }
 else
 {
  s.size = 0;
 }

 return s;
}

UArray *UArray_range(const UArray *self, size_t start, size_t size)
{
 UArray out = UArray_stackRange(self, start, size);
 return UArray_clone(&out);
}

UArray UArray_stackSlice(const UArray *self, long start, long end)
{
 start = UArray_wrapPos_(self, start);
 end = UArray_wrapPos_(self, end);
 if (end < start) end = start;
 return UArray_stackRange(self, start, end - start);
}

 UArray *UArray_slice(const UArray *self, long start, long end)
{
 UArray out = UArray_stackSlice(self, start, end);
 return UArray_clone(&out);
}



void *UArray_rawPointerAt_(const UArray *self, size_t i)
{
 if (self->itemType == CTYPE_uintptr_t)
 {
  return ((void **)self->data)[i];
 }

 UArray_error_(self, "UArray_rawPointerAt_ not supported on this type");
 return 0;
}

long UArray_rawLongAt_(const UArray *self, size_t i)
{
 switch (self->itemType) { case CTYPE_uint8_t: return ((uint8_t *)self->data)[i]; case CTYPE_uint16_t: return ((uint16_t *)self->data)[i]; case CTYPE_uint32_t: return ((uint32_t *)self->data)[i]; case CTYPE_uint64_t: return ((uint64_t *)self->data)[i]; case CTYPE_int8_t: return ((int8_t *)self->data)[i]; case CTYPE_int16_t: return ((int16_t *)self->data)[i]; case CTYPE_int32_t: return ((int32_t *)self->data)[i]; case CTYPE_int64_t: return ((int64_t *)self->data)[i]; case CTYPE_float32_t: return ((float32_t *)self->data)[i]; case CTYPE_float64_t: return ((float64_t *)self->data)[i]; case CTYPE_uintptr_t: return ((uintptr_t *)self->data)[i]; };
 UArray_error_(self, "UArray_rawLongAt_ not supported on this type");
 return 0;
}

double UArray_rawDoubleAt_(const UArray *self, size_t i)
{
 switch (self->itemType) { case CTYPE_uint8_t: return ((uint8_t *)self->data)[i]; case CTYPE_uint16_t: return ((uint16_t *)self->data)[i]; case CTYPE_uint32_t: return ((uint32_t *)self->data)[i]; case CTYPE_uint64_t: return ((uint64_t *)self->data)[i]; case CTYPE_int8_t: return ((int8_t *)self->data)[i]; case CTYPE_int16_t: return ((int16_t *)self->data)[i]; case CTYPE_int32_t: return ((int32_t *)self->data)[i]; case CTYPE_int64_t: return ((int64_t *)self->data)[i]; case CTYPE_float32_t: return ((float32_t *)self->data)[i]; case CTYPE_float64_t: return ((float64_t *)self->data)[i]; case CTYPE_uintptr_t: return ((uintptr_t *)self->data)[i]; };
 UArray_error_(self, "UArray_doubleAt_ not supported on this type");
 return 0;
}



void *UArray_pointerAt_(const UArray *self, size_t i)
{
 if (i >= self->size) { return 0; }
 return UArray_rawPointerAt_(self, i);
}

long UArray_longAt_(const UArray *self, size_t i)
{
 if (i >= self->size) { return 0; }
 return UArray_rawLongAt_(self, i);
}

double UArray_doubleAt_(const UArray *self, size_t i)
{
 if (i >= self->size) { return 0.0; }
 return UArray_rawDoubleAt_(self, i);
}



long UArray_firstLong(const UArray *self)
{
 return UArray_rawLongAt_(self, 0);
}

long UArray_lastLong(const UArray *self)
{
 if (!self->size)
 {
  return 0;
 }

 return UArray_rawLongAt_(self, self->size - 1);
}



void UArray_removeRange(UArray *self, size_t start, size_t removeSize)
{
 if (start < self->size)
 {
  if (start + removeSize > self->size)
  {
   removeSize = self->size - start;
  }
  else if (start + removeSize < self->size)
  {

   size_t remainder = start + removeSize;
   size_t remainderSize = self->size - remainder;
   memmove((self->data + (self->itemSize * start)), (self->data + (self->itemSize * remainder)), self -> itemSize * remainderSize);
  }

  UArray_setSize_(self, self->size - removeSize);
 }
 UArray_changed(self);
}

void UArray_leave_thenRemove_(UArray *self, size_t itemsToLeave, size_t itemsToRemove)
{
 if (itemsToLeave <= 0)
 {
  UArray_clear(self);
  UArray_setSize_(self, 0);
  return;
 }

 if (itemsToRemove <= 0)
 {
  return;
 }

 {
  size_t tailChunkSizeInBytes;

  size_t period = itemsToLeave + itemsToRemove;
  size_t tailItemCount = UArray_size(self) % period;
  size_t itemSize = self->itemSize;
  size_t chunkSizeInBytes = itemSize * itemsToLeave;

  if (tailItemCount == 0)
  {
   tailChunkSizeInBytes = 0;
  }
  else if (tailItemCount <= itemsToLeave)
  {
   tailChunkSizeInBytes = tailItemCount * itemSize;
  }
  else
  {
   tailChunkSizeInBytes = chunkSizeInBytes;
  }

  {
   size_t chunkCount = UArray_size(self) / period;
   size_t newItemCount = chunkCount * itemsToLeave + tailChunkSizeInBytes / itemSize;
   uint8_t *newData = malloc(newItemCount * itemSize);

   {
    size_t chunkPos;

    for (chunkPos = 0; chunkPos < chunkCount; chunkPos++)
    {
     memmove(newData + chunkPos * chunkSizeInBytes, (self->data + (self->itemSize * chunkPos * period)), chunkSizeInBytes);
    }

    if (tailChunkSizeInBytes)
    {
     memmove(newData + chunkPos * chunkSizeInBytes, (self->data + (self->itemSize * chunkPos * period)), tailChunkSizeInBytes);
    }

    UArray_setData_type_size_copy_(self, newData, UArray_itemType(self), newItemCount, 0);
    UArray_changed(self);
   }
  }
 }
}

 void UArray_removeFirst(UArray *self)
{
 UArray_removeRange(self, 0, 1);
}

 void UArray_removeLast(UArray *self)
{
 if (self->size > 0)
 {
  UArray_setSize_(self, self->size - 1);
 }
}
# 769 "UArray.c"
void UArray_at_putLong_(UArray *self, size_t pos, long v)
{
 if (pos >= self->size)
 {
  UArray_setSize_(self, pos + 1);
 }


 {
  switch (self->itemType){ case CTYPE_uint8_t: ((uint8_t *)self->data)[pos] = (uint32_t)v; return; case CTYPE_uint16_t: ((uint16_t *)self->data)[pos] = (uint32_t)v; return; case CTYPE_uint32_t: ((uint32_t *)self->data)[pos] = (uint32_t)v; return; case CTYPE_uint64_t: ((uint64_t *)self->data)[pos] = (uint32_t)v; return; case CTYPE_int8_t: ((int8_t *)self->data)[pos] = (uint32_t)v; return; case CTYPE_int16_t: ((int16_t *)self->data)[pos] = (uint32_t)v; return; case CTYPE_int32_t: ((int32_t *)self->data)[pos] = (uint32_t)v; return; case CTYPE_int64_t: ((int64_t *)self->data)[pos] = (uint32_t)v; return; case CTYPE_float32_t: ((float32_t *)self->data)[pos] = (uint32_t)v; return; case CTYPE_float64_t: ((float64_t *)self->data)[pos] = (uint32_t)v; return; case CTYPE_uintptr_t: ((uintptr_t *)self->data)[pos] = (uint32_t)v; return;};
  UArray_changed(self);
 }
}

void UArray_at_putDouble_(UArray *self, size_t pos, double v)
{
 if(pos >= self->size) UArray_setSize_(self, pos + 1);


 {
  switch (self->itemType){ case CTYPE_uint8_t: ((uint8_t *)self->data)[pos] = v; return; case CTYPE_uint16_t: ((uint16_t *)self->data)[pos] = v; return; case CTYPE_uint32_t: ((uint32_t *)self->data)[pos] = v; return; case CTYPE_uint64_t: ((uint64_t *)self->data)[pos] = v; return; case CTYPE_int8_t: ((int8_t *)self->data)[pos] = v; return; case CTYPE_int16_t: ((int16_t *)self->data)[pos] = v; return; case CTYPE_int32_t: ((int32_t *)self->data)[pos] = v; return; case CTYPE_int64_t: ((int64_t *)self->data)[pos] = v; return; case CTYPE_float32_t: ((float32_t *)self->data)[pos] = v; return; case CTYPE_float64_t: ((float64_t *)self->data)[pos] = v; return; case CTYPE_uintptr_t: ((uintptr_t *)self->data)[pos] = v; return;};
  UArray_changed(self);
 }
}

void UArray_at_putPointer_(UArray *self, size_t pos, void *v)
{
 if (pos >= self->size) UArray_setSize_(self, pos + 1);

 switch (self->itemType)
 {
  case CTYPE_uintptr_t:
   if(((void **)self->data)[pos] != v)
   {
    ((void **)self->data)[pos] = v;
    UArray_changed(self);
   }
   return;
  default:
   UArray_error_(self, "UArray_at_putPointer_ not supported with this type");
 }


}

void UArray_appendLong_(UArray *self, long v)
{
 UArray_at_putLong_(self, self->size, v);
}

void UArray_appendDouble_(UArray *self, double v)
{
 UArray_at_putDouble_(self, self->size, v);
}

void UArray_appendPointer_(UArray *self, void *v)
{
 UArray_at_putPointer_(self, self->size, v);
}

void UArray_appendBytes_size_(UArray *self, const uint8_t *bytes, size_t size)
{
 UArray a = UArray_stackAllocedWithData_type_size_((uint8_t *)bytes, CTYPE_uint8_t, size);
 UArray_append_(self, &a);
}
# 843 "UArray.c"
void UArray_insert_every_(UArray *self, UArray *other, size_t itemCount)
{
 UArray *out = UArray_new();
 UArray *convertedOther = other;

 if (itemCount == 0)
 {
  UArray_error_(self, "UArray_insert_every_: itemCount must be > 0");
  return;
 }

 if(UArray_itemType(self) != UArray_itemType(other))
 {
  UArray *convertedOther = UArray_clone(other);
  UArray_convertToItemType_(convertedOther, UArray_itemType(self));
 }

 {
  size_t selfSizeInBytes = UArray_sizeInBytes(self);
  size_t otherSize = UArray_size(convertedOther);
  size_t chunkSize = itemCount * UArray_itemSize(self);
  size_t i;

  for(i = 0; i < selfSizeInBytes; i += chunkSize)
  {
   if (i + chunkSize > selfSizeInBytes)
   {
    UArray_appendBytes_size_(out, self->data + i, selfSizeInBytes - i);
   }
   else
   {
    UArray_appendBytes_size_(out, self->data + i, chunkSize);
    UArray_appendBytes_size_(out, convertedOther->data, otherSize);
   }
  }
 }

 if(UArray_itemType(self) != UArray_itemType(other))
 {
  UArray_free(convertedOther);
 }

 UArray_copy_(self, out);
 UArray_free(out);
}

void UArray_at_putAll_(UArray *self, size_t pos, const UArray *other)
{
 if (other->size == 0) return;

 if (pos > self->size)
 {
  UArray_setSize_(self, pos);
 }

 {
  size_t chunkSize = self->size - pos;
  size_t originalSelfSize = self->size;

  UArray_setSize_(self, self->size + other->size);

  {
   UArray oldChunk = UArray_stackRange(self, pos, chunkSize);
   UArray newChunk = UArray_stackRange(self, pos + other->size, chunkSize);
   UArray insertChunk = UArray_stackRange(self, pos, other->size);

   if (

    (&insertChunk)->data == 0x0)
   {
    printf("oldChunk.data     %p size %i\n", (void *)(&oldChunk)->data, (int)oldChunk.size);
    printf("newChunk.data     %p size %i\n", (void *)(&newChunk)->data, (int)newChunk.size);
    printf("insertChunk.data  %p size %i\n", (void *)(&insertChunk)->data, (int)insertChunk.size);
    printf("originalSelfSize = %i\n", (int)originalSelfSize);
    printf("self->size  = %i\n", (int)self->size);
    printf("other->size = %i\n", (int)other->size);
    printf("pos = %i\n", (int)pos);


    oldChunk = UArray_stackRange(self, pos, chunkSize);
    newChunk = UArray_stackRange(self, pos + other->size, chunkSize);
    insertChunk = UArray_stackRange(self, pos, other->size);
    return;
   }

   if (newChunk.size)
   UArray_copyItems_(&newChunk, &oldChunk);

   UArray_copyItems_(&insertChunk, other);
  }

  UArray_changed(self);
 }
}
# 993 "UArray.c"
int UArray_compare_(const UArray *self, const UArray *other)
{
 if(self->itemType == CTYPE_uint32_t && other->itemType == CTYPE_uint8_t)
 {
  size_t i, minSize = self->size < other->size ? self->size : other->size;
  for(i = 0; i < minSize; i ++)
  {
   uint32_t v1 = ((uint32_t *)self->data)[i];
   uint8_t v2 = ((uint8_t *)other->data)[i];
   if (v1 > v2) return 1;
   if (v1 < v2) return -1;
  }
  if(self->size != other->size)
  {
   return self->size < other->size ? -1 : 1;
  }
 }
 else
 {
  switch (self->itemType) { case CTYPE_uint8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; }; case CTYPE_uint16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; }; case CTYPE_uint32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; }; case CTYPE_uint64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; }; case CTYPE_int8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; }; case CTYPE_int16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; }; case CTYPE_int32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; }; case CTYPE_int64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; }; case CTYPE_float32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; }; case CTYPE_float64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; }; case CTYPE_uintptr_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 1; if (v1 < v2) return -1; } if(self->size != other->size) { return self->size < other->size ? -1 : 1; } return 0;}; break; }; }; UArray_unsupported_with_(self, "NULL", other);;
 }

 return 0;
}

int UArray_equals_(const UArray *self, const UArray *other)
{
 if (self->size != other->size) return 0;
 switch (self->itemType) { case CTYPE_uint8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; }; case CTYPE_uint16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; }; case CTYPE_uint32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; }; case CTYPE_uint64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; }; case CTYPE_int8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; }; case CTYPE_int16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; }; case CTYPE_int32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; }; case CTYPE_int64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; }; case CTYPE_float32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; }; case CTYPE_float64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; }; case CTYPE_uintptr_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 != v2) return 0; } return 1;}; break; }; }; UArray_unsupported_with_(self, "NULL", other);;
 return 0;
}

int UArray_greaterThan_(const UArray *self, const UArray *other)
{
 if(self->encoding == CENCODING_NUMBER)
 { switch (self->itemType) { case CTYPE_uint8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; }; case CTYPE_uint16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; }; case CTYPE_uint32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; }; case CTYPE_uint64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; }; case CTYPE_int8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; }; case CTYPE_int16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; }; case CTYPE_int32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; }; case CTYPE_int64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; }; case CTYPE_float32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; }; case CTYPE_float64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; }; case CTYPE_uintptr_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 < v2) return 0; } return 1;}; break; }; }; UArray_unsupported_with_(self, "NULL", other);; }

 return UArray_compare_(self, other) > 0;
}

int UArray_lessThan_(const UArray *self, const UArray *other)
{
 if(self->encoding == CENCODING_NUMBER)
 { switch (self->itemType) { case CTYPE_uint8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint8_t v1 = ((uint8_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; }; case CTYPE_uint16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint16_t v1 = ((uint16_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; }; case CTYPE_uint32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; }; case CTYPE_uint64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; }; case CTYPE_int8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int8_t v1 = ((int8_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; }; case CTYPE_int16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { int16_t v1 = ((int16_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; }; case CTYPE_int32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint32_t v1 = ((uint32_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; }; case CTYPE_int64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uint64_t v1 = ((uint64_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; }; case CTYPE_float32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float32_t v1 = ((float32_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; }; case CTYPE_float64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { float64_t v1 = ((float64_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; }; case CTYPE_uintptr_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint8_t v2 = ((uint8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint16_t v2 = ((uint16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint32_t v2 = ((uint32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uint64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uint64_t v2 = ((uint64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int8_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int8_t v2 = ((int8_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int16_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int16_t v2 = ((int16_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int32_t v2 = ((int32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_int64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; int64_t v2 = ((int64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float32_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; float32_t v2 = ((float32_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_float64_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; float64_t v2 = ((float64_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; case CTYPE_uintptr_t: { size_t i, minSize = self->size < other->size ? self->size : other->size; for(i = 0; i < minSize; i ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; uintptr_t v2 = ((uintptr_t *)other->data)[i]; if (v1 > v2) return 0; } return 1;}; break; }; }; UArray_unsupported_with_(self, "NULL", other);; }

 return UArray_compare_(self, other) < 0;
}

int UArray_greaterThanOrEqualTo_(const UArray *self, const UArray *other)
{
 if(self->encoding == CENCODING_NUMBER)
 {
  if (UArray_greaterThan_(self, other) | UArray_equals_(self, other))
  { return 1; } else { return 0; }
 }

 return UArray_compare_(self, other) >= 0;
}

int UArray_lessThanOrEqualTo_(const UArray *self, const UArray *other)
{
 if(self->encoding == CENCODING_NUMBER)
 {
  if (UArray_lessThan_(self, other) | UArray_equals_(self, other))
  { return 1; } else { return 0; }
 }

 return UArray_compare_(self, other) <= 0;
}

int UArray_isZero(const UArray *self)
{
 switch(self->itemType) { case CTYPE_uint8_t: { size_t i; for(i = 0; i < self->size; i ++) { uint8_t v = ((uint8_t *)self->data)[i]; if (v) return 0;; } }; break;; case CTYPE_uint16_t: { size_t i; for(i = 0; i < self->size; i ++) { uint16_t v = ((uint16_t *)self->data)[i]; if (v) return 0;; } }; break;; case CTYPE_uint32_t: { size_t i; for(i = 0; i < self->size; i ++) { uint32_t v = ((uint32_t *)self->data)[i]; if (v) return 0;; } }; break;; case CTYPE_uint64_t: { size_t i; for(i = 0; i < self->size; i ++) { uint64_t v = ((uint64_t *)self->data)[i]; if (v) return 0;; } }; break;; case CTYPE_int8_t: { size_t i; for(i = 0; i < self->size; i ++) { int8_t v = ((int8_t *)self->data)[i]; if (v) return 0;; } }; break;; case CTYPE_int16_t: { size_t i; for(i = 0; i < self->size; i ++) { int16_t v = ((int16_t *)self->data)[i]; if (v) return 0;; } }; break;; case CTYPE_int32_t: { size_t i; for(i = 0; i < self->size; i ++) { int32_t v = ((int32_t *)self->data)[i]; if (v) return 0;; } }; break;; case CTYPE_int64_t: { size_t i; for(i = 0; i < self->size; i ++) { int64_t v = ((int64_t *)self->data)[i]; if (v) return 0;; } }; break;; case CTYPE_float32_t: { size_t i; for(i = 0; i < self->size; i ++) { float32_t v = ((float32_t *)self->data)[i]; if (v) return 0;; } }; break;; case CTYPE_float64_t: { size_t i; for(i = 0; i < self->size; i ++) { float64_t v = ((float64_t *)self->data)[i]; if (v) return 0;; } }; break;; case CTYPE_uintptr_t: { size_t i; for(i = 0; i < self->size; i ++) { uintptr_t v = ((uintptr_t *)self->data)[i]; if (v) return 0;; } }; break;; }
 return 1;
}
# 1093 "UArray.c"
long UArray_find_(const UArray *self, const UArray *other)
{
 switch (self->itemType) { case CTYPE_uint8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; }; case CTYPE_uint16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; }; case CTYPE_uint32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; }; case CTYPE_uint64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; }; case CTYPE_int8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; }; case CTYPE_int16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; }; case CTYPE_int32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; }; case CTYPE_int64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; }; case CTYPE_float32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; }; case CTYPE_float64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; }; case CTYPE_uintptr_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if((self->size < other->size) || (self->size == 0)) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if (match) return i; } return -1;}; break; }; }; UArray_unsupported_with_(self, "NULL", other);;
 return -1;
}

int UArray_contains_(const UArray *self, const UArray *other)
{
 return UArray_find_(self, other) != -1;
}

long UArray_find_from_(const UArray *self, const UArray *other, size_t from)
{
 UArray s;
 long i;
 if (self->size < from) return -1;
 s = UArray_stackRange(self, from, self->size - from);
 i = UArray_find_(&s, other);
 return i == -1 ? -1 : from + i;
}
# 1133 "UArray.c"
long UArray_findAnyCase_(const UArray *self, const UArray *other)
{
 switch (self->itemType) { case CTYPE_uint8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; }; case CTYPE_uint16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; }; case CTYPE_uint32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; }; case CTYPE_uint64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; }; case CTYPE_int8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; }; case CTYPE_int16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; }; case CTYPE_int32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; }; case CTYPE_int64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; }; case CTYPE_float32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; }; case CTYPE_float64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; }; case CTYPE_uintptr_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uint64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int8_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; int8_t v2 = ((int8_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int16_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; int16_t v2 = ((int16_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; int32_t v2 = ((int32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_int64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; int64_t v2 = ((int64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float32_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; float32_t v2 = ((float32_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_float64_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; float64_t v2 = ((float64_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; case CTYPE_uintptr_t: { size_t i; if(self->size < other->size) return -1; for(i = 0; i < self->size - other->size + 1; i ++) { size_t j; int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i + j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (tolower((int)v1) != tolower((int)v2)) { match = 0; break; } } if(match) { return i; } } return -1;}; break; }; }; UArray_unsupported_with_(self, "NULL", other);;
 return -1;
}

int UArray_containsAnyCase_(const UArray *self, const UArray *other)
{
 long i = UArray_findAnyCase_(self, other);
 return i != -1;
}

long UArray_findLongValue_(const UArray *self, long value)
{
 switch(self->itemType) { case CTYPE_uint8_t: { size_t i; for(i = 0; i < self->size; i ++) { uint8_t v = ((uint8_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_uint16_t: { size_t i; for(i = 0; i < self->size; i ++) { uint16_t v = ((uint16_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_uint32_t: { size_t i; for(i = 0; i < self->size; i ++) { uint32_t v = ((uint32_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_uint64_t: { size_t i; for(i = 0; i < self->size; i ++) { uint64_t v = ((uint64_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_int8_t: { size_t i; for(i = 0; i < self->size; i ++) { int8_t v = ((int8_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_int16_t: { size_t i; for(i = 0; i < self->size; i ++) { int16_t v = ((int16_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_int32_t: { size_t i; for(i = 0; i < self->size; i ++) { int32_t v = ((int32_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_int64_t: { size_t i; for(i = 0; i < self->size; i ++) { int64_t v = ((int64_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_float32_t: { size_t i; for(i = 0; i < self->size; i ++) { float32_t v = ((float32_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_float64_t: { size_t i; for(i = 0; i < self->size; i ++) { float64_t v = ((float64_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_uintptr_t: { size_t i; for(i = 0; i < self->size; i ++) { uintptr_t v = ((uintptr_t *)self->data)[i]; if(v == value) return i; } }; break;; };
 return -1;
}

int UArray_containsLong_(const UArray *self, long value)
{
 return UArray_findLongValue_(self, value) != -1;
}

long UArray_findDoubleValue_(const UArray *self, double value)
{
 switch(self->itemType) { case CTYPE_uint8_t: { size_t i; for(i = 0; i < self->size; i ++) { uint8_t v = ((uint8_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_uint16_t: { size_t i; for(i = 0; i < self->size; i ++) { uint16_t v = ((uint16_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_uint32_t: { size_t i; for(i = 0; i < self->size; i ++) { uint32_t v = ((uint32_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_uint64_t: { size_t i; for(i = 0; i < self->size; i ++) { uint64_t v = ((uint64_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_int8_t: { size_t i; for(i = 0; i < self->size; i ++) { int8_t v = ((int8_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_int16_t: { size_t i; for(i = 0; i < self->size; i ++) { int16_t v = ((int16_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_int32_t: { size_t i; for(i = 0; i < self->size; i ++) { int32_t v = ((int32_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_int64_t: { size_t i; for(i = 0; i < self->size; i ++) { int64_t v = ((int64_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_float32_t: { size_t i; for(i = 0; i < self->size; i ++) { float32_t v = ((float32_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_float64_t: { size_t i; for(i = 0; i < self->size; i ++) { float64_t v = ((float64_t *)self->data)[i]; if(v == value) return i; } }; break;; case CTYPE_uintptr_t: { size_t i; for(i = 0; i < self->size; i ++) { uintptr_t v = ((uintptr_t *)self->data)[i]; if(v == value) return i; } }; break;; };
 return -1;
}

int UArray_containsDouble_(const UArray *self, double value)
{
 return UArray_findDoubleValue_(self, value) != -1;
}
# 1185 "UArray.c"
long UArray_rFind_(const UArray *self, const UArray *other)
{
 switch (self->itemType) { case CTYPE_uint8_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i+j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i+j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i+j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i+j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i+j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i+j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i+j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i+j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i+j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i+j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint8_t v1 = ((uint8_t *)self->data)[i+j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; }; case CTYPE_uint16_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i+j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i+j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i+j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i+j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i+j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i+j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i+j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i+j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i+j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i+j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint16_t v1 = ((uint16_t *)self->data)[i+j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; }; case CTYPE_uint32_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; }; case CTYPE_uint64_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; }; case CTYPE_int8_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i+j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i+j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i+j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i+j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i+j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i+j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i+j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i+j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i+j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i+j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int8_t v1 = ((int8_t *)self->data)[i+j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; }; case CTYPE_int16_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i+j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i+j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i+j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i+j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i+j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i+j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i+j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i+j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i+j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i+j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int16_t v1 = ((int16_t *)self->data)[i+j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; }; case CTYPE_int32_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint32_t v1 = ((uint32_t *)self->data)[i+j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; }; case CTYPE_int64_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uint64_t v1 = ((uint64_t *)self->data)[i+j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; }; case CTYPE_float32_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i+j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i+j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i+j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i+j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i+j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i+j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i+j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i+j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i+j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i+j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float32_t v1 = ((float32_t *)self->data)[i+j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; }; case CTYPE_float64_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i+j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i+j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i+j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i+j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i+j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i+j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i+j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i+j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i+j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i+j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { float64_t v1 = ((float64_t *)self->data)[i+j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; }; case CTYPE_uintptr_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i+j]; uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i+j]; uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i+j]; uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i+j]; uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i+j]; int8_t v2 = ((int8_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i+j]; int16_t v2 = ((int16_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i+j]; int32_t v2 = ((int32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i+j]; int64_t v2 = ((int64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i+j]; float32_t v2 = ((float32_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i+j]; float64_t v2 = ((float64_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { uintptr_t v1 = ((uintptr_t *)self->data)[i+j]; uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 != v2) { match = 0; break; } } if(match) { return i;} } return -1;}; break; }; }; UArray_unsupported_with_(self, "NULL", other);;
 return -1;
}

 long UArray_rFind_from_(const UArray *self, const UArray *other, size_t from)
{
 UArray s = UArray_stackRange(self, 0, from);
 long i = UArray_rFind_(&s, other);
 return i;
}
# 1216 "UArray.c"
long UArray_rFindAnyCase_(const UArray *self, const UArray *other)
{
 switch (self->itemType) { case CTYPE_uint8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint8_t *)self->data)[i+j]; int v2 = (int)((uint8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint8_t *)self->data)[i+j]; int v2 = (int)((uint16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint8_t *)self->data)[i+j]; int v2 = (int)((uint32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint8_t *)self->data)[i+j]; int v2 = (int)((uint64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint8_t *)self->data)[i+j]; int v2 = (int)((int8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint8_t *)self->data)[i+j]; int v2 = (int)((int16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint8_t *)self->data)[i+j]; int v2 = (int)((int32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint8_t *)self->data)[i+j]; int v2 = (int)((int64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint8_t *)self->data)[i+j]; int v2 = (int)((float32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint8_t *)self->data)[i+j]; int v2 = (int)((float64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint8_t *)self->data)[i+j]; int v2 = (int)((uintptr_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; }; case CTYPE_uint16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint16_t *)self->data)[i+j]; int v2 = (int)((uint8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint16_t *)self->data)[i+j]; int v2 = (int)((uint16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint16_t *)self->data)[i+j]; int v2 = (int)((uint32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint16_t *)self->data)[i+j]; int v2 = (int)((uint64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint16_t *)self->data)[i+j]; int v2 = (int)((int8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint16_t *)self->data)[i+j]; int v2 = (int)((int16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint16_t *)self->data)[i+j]; int v2 = (int)((int32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint16_t *)self->data)[i+j]; int v2 = (int)((int64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint16_t *)self->data)[i+j]; int v2 = (int)((float32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint16_t *)self->data)[i+j]; int v2 = (int)((float64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint16_t *)self->data)[i+j]; int v2 = (int)((uintptr_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; }; case CTYPE_uint32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((uint8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((uint16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((uint32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((uint64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((int8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((int16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((int32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((int64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((float32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((float64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((uintptr_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; }; case CTYPE_uint64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((uint8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((uint16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((uint32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((uint64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((int8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((int16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((int32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((int64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((float32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((float64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((uintptr_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; }; case CTYPE_int8_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int8_t *)self->data)[i+j]; int v2 = (int)((uint8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int8_t *)self->data)[i+j]; int v2 = (int)((uint16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int8_t *)self->data)[i+j]; int v2 = (int)((uint32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int8_t *)self->data)[i+j]; int v2 = (int)((uint64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int8_t *)self->data)[i+j]; int v2 = (int)((int8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int8_t *)self->data)[i+j]; int v2 = (int)((int16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int8_t *)self->data)[i+j]; int v2 = (int)((int32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int8_t *)self->data)[i+j]; int v2 = (int)((int64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int8_t *)self->data)[i+j]; int v2 = (int)((float32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int8_t *)self->data)[i+j]; int v2 = (int)((float64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int8_t *)self->data)[i+j]; int v2 = (int)((uintptr_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; }; case CTYPE_int16_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int16_t *)self->data)[i+j]; int v2 = (int)((uint8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int16_t *)self->data)[i+j]; int v2 = (int)((uint16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int16_t *)self->data)[i+j]; int v2 = (int)((uint32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int16_t *)self->data)[i+j]; int v2 = (int)((uint64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int16_t *)self->data)[i+j]; int v2 = (int)((int8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int16_t *)self->data)[i+j]; int v2 = (int)((int16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int16_t *)self->data)[i+j]; int v2 = (int)((int32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int16_t *)self->data)[i+j]; int v2 = (int)((int64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int16_t *)self->data)[i+j]; int v2 = (int)((float32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int16_t *)self->data)[i+j]; int v2 = (int)((float64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((int16_t *)self->data)[i+j]; int v2 = (int)((uintptr_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; }; case CTYPE_int32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((uint8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((uint16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((uint32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((uint64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((int8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((int16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((int32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((int64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((float32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((float64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint32_t *)self->data)[i+j]; int v2 = (int)((uintptr_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; }; case CTYPE_int64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((uint8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((uint16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((uint32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((uint64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((int8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((int16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((int32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((int64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((float32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((float64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uint64_t *)self->data)[i+j]; int v2 = (int)((uintptr_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; }; case CTYPE_float32_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float32_t *)self->data)[i+j]; int v2 = (int)((uint8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float32_t *)self->data)[i+j]; int v2 = (int)((uint16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float32_t *)self->data)[i+j]; int v2 = (int)((uint32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float32_t *)self->data)[i+j]; int v2 = (int)((uint64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float32_t *)self->data)[i+j]; int v2 = (int)((int8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float32_t *)self->data)[i+j]; int v2 = (int)((int16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float32_t *)self->data)[i+j]; int v2 = (int)((int32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float32_t *)self->data)[i+j]; int v2 = (int)((int64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float32_t *)self->data)[i+j]; int v2 = (int)((float32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float32_t *)self->data)[i+j]; int v2 = (int)((float64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float32_t *)self->data)[i+j]; int v2 = (int)((uintptr_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; }; case CTYPE_float64_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float64_t *)self->data)[i+j]; int v2 = (int)((uint8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float64_t *)self->data)[i+j]; int v2 = (int)((uint16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float64_t *)self->data)[i+j]; int v2 = (int)((uint32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float64_t *)self->data)[i+j]; int v2 = (int)((uint64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float64_t *)self->data)[i+j]; int v2 = (int)((int8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float64_t *)self->data)[i+j]; int v2 = (int)((int16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float64_t *)self->data)[i+j]; int v2 = (int)((int32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float64_t *)self->data)[i+j]; int v2 = (int)((int64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float64_t *)self->data)[i+j]; int v2 = (int)((float32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float64_t *)self->data)[i+j]; int v2 = (int)((float64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((float64_t *)self->data)[i+j]; int v2 = (int)((uintptr_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; }; case CTYPE_uintptr_t: switch (other->itemType) { case CTYPE_uint8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uintptr_t *)self->data)[i+j]; int v2 = (int)((uint8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uintptr_t *)self->data)[i+j]; int v2 = (int)((uint16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uintptr_t *)self->data)[i+j]; int v2 = (int)((uint32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uint64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uintptr_t *)self->data)[i+j]; int v2 = (int)((uint64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int8_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uintptr_t *)self->data)[i+j]; int v2 = (int)((int8_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int16_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uintptr_t *)self->data)[i+j]; int v2 = (int)((int16_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uintptr_t *)self->data)[i+j]; int v2 = (int)((int32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_int64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uintptr_t *)self->data)[i+j]; int v2 = (int)((int64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float32_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uintptr_t *)self->data)[i+j]; int v2 = (int)((float32_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_float64_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uintptr_t *)self->data)[i+j]; int v2 = (int)((float64_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; case CTYPE_uintptr_t: { size_t i, j; if(self->size < other->size) return -1; for(i = self->size - other->size + 1; i > -1; i --) { int match = 1; for(j = 0; j < other->size; j ++) { int v1 = (int)((uintptr_t *)self->data)[i+j]; int v2 = (int)((uintptr_t *)other->data)[j]; if (tolower(v1) != tolower(v2)) { match = 0; break; } } if(match) return i; } return -1;}; break; }; }; UArray_unsupported_with_(self, "NULL", other);;
 return -1;
}
# 1238 "UArray.c"
long UArray_rFindAnyValue_(const UArray *self, const UArray *other)
{
 switch (self->itemType) { case CTYPE_uint8_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint8_t v1 = ((uint8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint8_t v1 = ((uint8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint8_t v1 = ((uint8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint8_t v1 = ((uint8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint8_t v1 = ((uint8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int8_t v2 = ((int8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint8_t v1 = ((uint8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int16_t v2 = ((int16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint8_t v1 = ((uint8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int32_t v2 = ((int32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint8_t v1 = ((uint8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int64_t v2 = ((int64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint8_t v1 = ((uint8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float32_t v2 = ((float32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint8_t v1 = ((uint8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float64_t v2 = ((float64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint8_t v1 = ((uint8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; }; case CTYPE_uint16_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint16_t v1 = ((uint16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint16_t v1 = ((uint16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint16_t v1 = ((uint16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint16_t v1 = ((uint16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint16_t v1 = ((uint16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int8_t v2 = ((int8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint16_t v1 = ((uint16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int16_t v2 = ((int16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint16_t v1 = ((uint16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int32_t v2 = ((int32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint16_t v1 = ((uint16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int64_t v2 = ((int64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint16_t v1 = ((uint16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float32_t v2 = ((float32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint16_t v1 = ((uint16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float64_t v2 = ((float64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint16_t v1 = ((uint16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; }; case CTYPE_uint32_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int8_t v2 = ((int8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int16_t v2 = ((int16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int32_t v2 = ((int32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int64_t v2 = ((int64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float32_t v2 = ((float32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float64_t v2 = ((float64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; }; case CTYPE_uint64_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int8_t v2 = ((int8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int16_t v2 = ((int16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int32_t v2 = ((int32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int64_t v2 = ((int64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float32_t v2 = ((float32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float64_t v2 = ((float64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; }; case CTYPE_int8_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int8_t v1 = ((int8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int8_t v1 = ((int8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int8_t v1 = ((int8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int8_t v1 = ((int8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int8_t v1 = ((int8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int8_t v2 = ((int8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int8_t v1 = ((int8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int16_t v2 = ((int16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int8_t v1 = ((int8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int32_t v2 = ((int32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int8_t v1 = ((int8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int64_t v2 = ((int64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int8_t v1 = ((int8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float32_t v2 = ((float32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int8_t v1 = ((int8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float64_t v2 = ((float64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int8_t v1 = ((int8_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; }; case CTYPE_int16_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int16_t v1 = ((int16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int16_t v1 = ((int16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int16_t v1 = ((int16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int16_t v1 = ((int16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int16_t v1 = ((int16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int8_t v2 = ((int8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int16_t v1 = ((int16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int16_t v2 = ((int16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int16_t v1 = ((int16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int32_t v2 = ((int32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int16_t v1 = ((int16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int64_t v2 = ((int64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int16_t v1 = ((int16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float32_t v2 = ((float32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int16_t v1 = ((int16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float64_t v2 = ((float64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { int16_t v1 = ((int16_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; }; case CTYPE_int32_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int8_t v2 = ((int8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int16_t v2 = ((int16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int32_t v2 = ((int32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int64_t v2 = ((int64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float32_t v2 = ((float32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float64_t v2 = ((float64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint32_t v1 = ((uint32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; }; case CTYPE_int64_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int8_t v2 = ((int8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int16_t v2 = ((int16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int32_t v2 = ((int32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int64_t v2 = ((int64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float32_t v2 = ((float32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float64_t v2 = ((float64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uint64_t v1 = ((uint64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; }; case CTYPE_float32_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float32_t v1 = ((float32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float32_t v1 = ((float32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float32_t v1 = ((float32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float32_t v1 = ((float32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float32_t v1 = ((float32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int8_t v2 = ((int8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float32_t v1 = ((float32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int16_t v2 = ((int16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float32_t v1 = ((float32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int32_t v2 = ((int32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float32_t v1 = ((float32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int64_t v2 = ((int64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float32_t v1 = ((float32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float32_t v2 = ((float32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float32_t v1 = ((float32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float64_t v2 = ((float64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float32_t v1 = ((float32_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; }; case CTYPE_float64_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float64_t v1 = ((float64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float64_t v1 = ((float64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float64_t v1 = ((float64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float64_t v1 = ((float64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float64_t v1 = ((float64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int8_t v2 = ((int8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float64_t v1 = ((float64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int16_t v2 = ((int16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float64_t v1 = ((float64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int32_t v2 = ((int32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float64_t v1 = ((float64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int64_t v2 = ((int64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float64_t v1 = ((float64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float32_t v2 = ((float32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float64_t v1 = ((float64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float64_t v2 = ((float64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { float64_t v1 = ((float64_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; }; case CTYPE_uintptr_t: switch (other->itemType) { case CTYPE_uint8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint8_t v2 = ((uint8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint16_t v2 = ((uint16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint32_t v2 = ((uint32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uint64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uint64_t v2 = ((uint64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int8_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int8_t v2 = ((int8_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int16_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int16_t v2 = ((int16_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int32_t v2 = ((int32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_int64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { int64_t v2 = ((int64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float32_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float32_t v2 = ((float32_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_float64_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { float64_t v2 = ((float64_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; case CTYPE_uintptr_t: { long i, j; if(self->size < other->size) return -1; for(i = self->size - 1; i > -1; i --) { uintptr_t v1 = ((uintptr_t *)self->data)[i]; for(j = 0; j < other->size; j ++) { uintptr_t v2 = ((uintptr_t *)other->data)[j]; if (v1 == v2) { return i; } } } return -1;}; break; }; }; UArray_unsupported_with_(self, "NULL", other);;
 return -1;
}



int UArray_isFloatType(const UArray *self)
{
 return self->itemType == CTYPE_float32_t || self->itemType == CTYPE_float64_t;
}

int UArray_isSignedType(const UArray *self)
{
 switch (self->itemType)
 {
  case CTYPE_uint8_t: return 0;
  case CTYPE_uint16_t: return 0;
  case CTYPE_uint32_t: return 0;
  case CTYPE_uint64_t: return 0;
  case CTYPE_int8_t: return 1;
  case CTYPE_int16_t: return 1;
  case CTYPE_int32_t: return 1;
  case CTYPE_int64_t: return 1;
  case CTYPE_float32_t: return 1;
  case CTYPE_float64_t: return 1;
  case CTYPE_uintptr_t: return 0;
 }
 return 0;
}

size_t UArray_wrapPos_(const UArray *self, long pos)
{
 long size = self->size;

 if (pos > size - 1)
 {
  return size;
 }

 if (pos < 0)
 {
  pos = size + pos;

  if (pos < 0)
  {
   pos = 0;
  }
 }

 return pos;
}

int cmp_uint8_t (const uint8_t *a, const uint8_t *b) { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
int cmp_uint16_t(const uint16_t *a, const uint16_t *b) { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
int cmp_uint32_t(const uint32_t *a, const uint32_t *b) { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
int cmp_uint64_t(const uint64_t *a, const uint64_t *b) { return *a == *b ? 0 : (*a < *b ? -1 : 1); }

int cmp_int8_t (const int8_t *a, const int8_t *b) { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
int cmp_int16_t(const int16_t *a, const int16_t *b) { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
int cmp_int32_t(const int32_t *a, const int32_t *b) { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
int cmp_int64_t(const int64_t *a, const int64_t *b) { return *a == *b ? 0 : (*a < *b ? -1 : 1); }

int cmp_float32_t(const float32_t *a, const float32_t *b) { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
int cmp_float64_t(const float64_t *a, const float64_t *b) { return *a == *b ? 0 : (*a < *b ? -1 : 1); }
int cmp_uintptr_t(const uintptr_t *a, const uintptr_t *b) { return *a == *b ? 0 : (*a < *b ? -1 : 1); }

void UArray_sort(UArray *self)
{
 void *base = self->data;
 size_t size = self->size;

 UArray_changed(self);

 switch(self->itemType)
 {
  case CTYPE_uint8_t: qsort(base, size, sizeof(uint8_t), (UArraySortCallback *)cmp_uint8_t); return;
  case CTYPE_uint16_t: qsort(base, size, sizeof(uint16_t), (UArraySortCallback *)cmp_uint16_t); return;
  case CTYPE_uint32_t: qsort(base, size, sizeof(uint32_t), (UArraySortCallback *)cmp_uint32_t); return;
  case CTYPE_uint64_t: qsort(base, size, sizeof(uint64_t), (UArraySortCallback *)cmp_uint64_t); return;

  case CTYPE_int8_t: qsort(base, size, sizeof(int8_t), (UArraySortCallback *)cmp_int8_t); return;
  case CTYPE_int16_t: qsort(base, size, sizeof(int16_t), (UArraySortCallback *)cmp_int16_t); return;
  case CTYPE_int32_t: qsort(base, size, sizeof(int32_t), (UArraySortCallback *)cmp_int32_t); return;
  case CTYPE_int64_t: qsort(base, size, sizeof(int64_t), (UArraySortCallback *)cmp_int64_t); return;

  case CTYPE_float32_t: qsort(base, size, sizeof(float32_t), (UArraySortCallback *)cmp_float32_t); return;
  case CTYPE_float64_t: qsort(base, size, sizeof(float64_t), (UArraySortCallback *)cmp_float64_t); return;
  case CTYPE_uintptr_t: qsort(base, size, sizeof(uintptr_t), (UArraySortCallback *)cmp_uintptr_t); return;
 }
}

void UArray_sortBy_(UArray *self, UArraySortCallback *cmp)
{
 void *base = self->data;
 size_t size = self->size;

 UArray_changed(self);

 switch(self->itemType)
 {
  case CTYPE_uint8_t: qsort(base, size, sizeof(uint8_t), cmp); return;
  case CTYPE_uint16_t: qsort(base, size, sizeof(uint16_t), cmp); return;
  case CTYPE_uint32_t: qsort(base, size, sizeof(uint32_t), cmp); return;
  case CTYPE_uint64_t: qsort(base, size, sizeof(uint64_t), cmp); return;

  case CTYPE_int8_t: qsort(base, size, sizeof(int8_t), cmp); return;
  case CTYPE_int16_t: qsort(base, size, sizeof(int16_t), cmp); return;
  case CTYPE_int32_t: qsort(base, size, sizeof(int32_t), cmp); return;
  case CTYPE_int64_t: qsort(base, size, sizeof(int64_t), cmp); return;

  case CTYPE_float32_t: qsort(base, size, sizeof(float32_t), cmp); return;
  case CTYPE_float64_t: qsort(base, size, sizeof(float64_t), cmp); return;
  case CTYPE_uintptr_t: qsort(base, size, sizeof(uintptr_t), cmp); return;
 }
}
